# ai-prompt-demo
Some awesome prompt demo for LLM 

## Principles

### 使用明确、精准的语言

**技巧**：避免模糊、冗余或含糊的表述，确保指令清晰、无歧义，尽量精准简短。

**Bad Case**：尝试创建一个程序，能处理一些数字计算任务。

**Good Case**：编写一个Python程序，实现对两个浮点数进行加、减、乘、除四则运算，并提供用户友好的命令行界面。

### 提供具体的输入/输出示例

**技巧**：在与通义灵码交互时，务必提供实际的输入数据和预期输出结果，以帮助灵码直观理解你的测试用例需求，确保其生成的代码能准确覆盖所需测试场景。

**Bad Case**：编写一个测试用例，验证一个反转字符串函数的行为。

**Good Case**：
- 测试函数名称：test_reverse_string
- 输入数据：
    - 待反转字符串："Hello, World!"
- 预期输出：
    - 函数返回结果："!dlroW ,olleH"

在这个改进案例中，我们不仅指定了测试函数名称，还提供了待反转字符串 "Hello, World!" 作为输入数据，以及期望的反转结果 "!dlroW ,olleH"。这种明确、具体的输入/输出示例有助于通义灵码准确理解测试意图，从而生成符合要求的测试代码，确保字符串反转函数的功能得到正确验证。

### 明确数据类型和格式要求
详细说明输入参数、返回值以及中间结果的数据类型、结构和格式。

**Bad Case**：编写一个函数，处理一串数字。

**Good Case**：编写一个名为`sum_of_even_numbers`的函数，接受一个类型为`List[int]`的参数`numbers`，返回列表中所有偶数之和。返回值应为`int`类型。

该案例清晰指定了函数的输入参数类型（整数列表）和返回值类型（整数），确保编写者明确了解函数应接收何种格式的数据作为输入，以及最终应返回何种形式的结果。这种详细的说明有助于避免因数据类型或格式误解导致的代码错误，确保函数实现的准确性与一致性。

### 描述异常情况及处理方式
指出可能遇到的异常情况及期望的错误处理策略。

**Bad Case**：编写一个函数，读取指定路径下的CSV文件，并将其内容转换为DataFrame。

**Good Case**：编写一个`read_csv_to_dataframe`的函数，接受一个类型为`str`的参数`file_path`，表示要读取的CSV文件路径。函数应尝试打开并解析该文件，将其内容转化为Pandas DataFrame对象并返回。在处理过程中，考虑并妥善处理以下异常情况：

1. **FileNotFoundError**：当指定的文件路径不存在时，抛出`FileNotFoundError`并附带提示信息，如：“指定的CSV文件路径不存在：{file_path}”。
2. **PermissionError**：如果用户没有足够的权限访问或读取文件，抛出`PermissionError`并附带提示信息，如：“无权访问指定的CSV文件：{file_path}”。
3. **UnicodeDecodeError**：如果CSV文件包含无法正确解码的字符，尝试使用`chardet`库检测文件编码，然后使用正确的编码重新读取。如果仍无法成功解码，抛出`UnicodeDecodeError`并附带提示信息，如：“无法解码CSV文件（可能编码不正确）：{file_path}”。
4. **csv.Error**：在解析CSV文件内容时，如果遇到不符合CSV格式规范的情况（如缺失分隔符、嵌套引号等），捕获`csv.Error`异常，抛出并附带提示信息，如：“CSV文件格式错误：{file_path}”。
5. **其他异常**：对于未明确列举的其他异常，函数应捕获并抛出一个自定义的异常（如`CSVReadException`），包含原始异常信息和文件路径，以便于调试和问题定位。例如：“读取CSV文件时发生未知错误（{original_exception_message}）：{file_path}”。
返回值：成功读取并转换为DataFrame的CSV文件内容。

### 设定性能、资源或限制条件
明确提出`时间复杂度`、`空间复杂度`、`内存限制`、`第三方库使用限制`等约束。

**Bad Case**：编写一个函数，对给定的大规模文本进行分词处理。
**Good Case**：编写一个`tokenize_large_text`的函数，接受一个类型为`str`的参数`text`，表示要进行分词处理的大规模文本数据。函数应将文本数据进行高效地分词，并返回一个类型为`List[str]`的结果列表，包含所有分词结果。在设计和实现该函数时，考虑以下性能、资源和限制条件：

1. **性能要求**：对于大小为1GB的文本数据（约1亿个字符，假设平均字符数为一个汉字或者两个英文字符），分词处理应在单核CPU上不超过30秒完成。为了评估性能，可以使用包含随机生成或实际样本数据的测试
2. **内存限制**：函数应能在不超过4GB的内存环境中运行。避免一次性加载整个文本到内存，而是采用流式处理、分块读取或其他内存优化策略。
3. **分词工具**：使用成熟的分词库（如jieba、NLTK、spaCy等进行分词），但不得直接调用其提供的文本文件分词接口。需自行实现基于这些库的高效文本流处理逻辑。
4. **编码兼容**：确保函数能正确处理UTF-8编码的文本数据，对于非UTF-8编码的文本，函数应抛出`UnicodeDecodeError`并附带提示信息，如：“输入文本不是有效的UTF-8编码”。
5. 返回值：分词后的结果列表，类型为`List[str]`。

在这个案例中，我们为大规模文本分词任务设定了具体的性能要求（处理时间）、内存限制，指定了使用的分词工具，并明确了编码兼容性要求。这些条件为实现者提供了明确的优化方向和约束边界，有助于开发出既满足业务需求又具备良好资源效率的解决方案。

### 增加强调词和强调符号
使用强调词汇或符号突出关键指令，确保灵码充分重视并准确执行。

**Bad Case**：编写一个测试脚本，使用Jest框测试框架对React组件进行单元测试。
**Good Case**：**请务必**编写一个详尽的测试脚本，利用**业界领先的 Jest 测试框架**对**核心 React 组件库**进行全面的单元测试。遵循以下强调要点：

1. **_务必覆盖_**所有公共方法（包括生命周期方法、自定义事件处理器等）和重要的私有辅助方法，确保**高代码覆盖率***（至少达到 **95%**）。
2. **正确模拟**组件的依赖项（如 Redux store、API 调用、第三方库等），使用合适的 **Jest Mocking 工具**（如 `jest.fn()`）、`jest.mock()`）和测试双射（Test Doubles）。
3. **严格执行**React 组件的**渲染输出验证**，利用 Jest 的 Snapshot Testing 功能或 Enzyme/Jest-React 的快照测试，确保 UI 结构与样式的一致性。
4. **全面检查**组件的**交互行为**，通过触发事件，模拟异步响应等方式，验证状态变更、回调触发、路由跳转等预期行为。
5. **遵循最佳实践**，保持测试用例的**原子性**、**独立性**和**可读性**，合理组织测试文件结构，使用`describe()`和`it()`块划分测试逻辑。
6. **确保测试稳定性**，避免因外部依赖变化导致的测试失败，定期更新并维护测试数据及 Mock 数据。

在这个案例中，我们使用了强调词汇（如“务必”、“正确”、“严格执行”、“全面检查”、“遵循最佳实践”、“确保”等）和强调符号（如粗体、斜体）来突出单元测试脚本编写过程中的关键要求和注意事项，帮助灵码或开发者更好地理解和执行测试任务。

### 撰写模块化的Prompt

**技巧**：将Prompt分为明确的模块，如任务描述、输入数据、预期输出、约束条件等，提升代码可读性和交互效率。

**Bad Case**：编写一个用户登录功能的后端API

**Good Case**：

实现后端`POST /api/users/login`端点，处理如下JSON请求：

```json
{
    "email": "user@example.com",
    "password": "secretpassword"
}
```
**响应**：
- **成功（HTTP 200）**：返回JWT access_token 与 refresh_token。
- **失败（HTTP 401）**：返回错误信息“Invalid email or password”。
**约束**：
1. **验证**：检查email格式与用户存在性，验证非空密码。
2. **密码校验**：使用bcrypt对比哈希密码，失败返回401
3. **令牌生成**：登录成功生成JWT tokens。
4. **安全**：保护密码安全，使用HTTPS。

此 Good Case 明确了用户登录API的响应内容以及实现时需要遵循的约束条件，能快速精准输出有效代码片段。

### 基于代码上下文来提问
**技巧**：在灵码交互时，附带相关代码片段、报错堆栈或项目背景信息，有助于模型更好地理解任务需求，生成符合现有代码结构和项目逻辑的代码，甚至可以一键帮你排查问题并输出优化代码。

**Bad Case**：仅提供孤立的编程任务要求，如“实现一个函数，计算两个矩阵的乘法”。
**Good Case**：提供包含已有代码的上下文信息，例如：“在以下矩阵操作类中，添加一个名为`matrix_multiply`的方法，实现两个同型矩阵的乘法运算。请确保与已有的`add`、`subtract`方法保持一致的接口风格。”

学会这些技巧，你将能与AI编程助手建立起更为默契的工作关系，使它更准确地领会你的编程需求，从而生成满足你期望的高质量代码。

